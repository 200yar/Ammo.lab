<!DOCTYPE html>
<html lang="en">
<head>
<title>Ammo lab</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style>
    * {  margin: 0; padding: 0; border: 0;}
    @font-face { font-family: "SourceCode"; src:url("images/SourceCodePro.woff") format("woff");}
    body { background-color: #383838; overflow: hidden; color: #eeeeee; font-family: "SourceCode"; font-size: 12px; }
    h3 { font-size: 16px; }
    input{ margin:0; padding:4px; }
    #interface{ position: absolute; left:10px; top:10px; width:456px; height:20px; }
    #info{ pointer-events:none; position: absolute; left:10px; top:10px; width: 400px; height: 400px; }
</style>

<script src="js/PNGtoSCRIPT.js"></script>
<script src="js/Editor.js"></script>
<script src="js/Terrain.js"></script>

</head>

<body>
<div id='container'></div>
<div id="info"></div>

<script>

// Parameters
var ToRad = Math.PI / 180;
var info = document.getElementById("info");

// THREE var
var container, camera, scene, renderer, camPos, mouse, content, ground
var terrain = null;
var fps=0, time, time_prev=0, fpsint = 0;
var bgcolor = 0x606060;
var clock;
var pool;
var Editor;
var vmid = 1, hmid = 1;
var scriptLoader;
var viewSize = {w:1, h:1};

var meshs = [];
var geos = [];
var mats = [];

var directionalLight;
var pointLight;
var hemiLight;
//-----------------------------------
// ALL SOURCE LOADED FROM PNG 
//-----------------------------------

window.onload = prevInit;

function prevInit() {
    scriptLoader = new PNGtoSCRIPT.Loader([ "images/ammo.png", "images/three.png", "images/sea3d.png"], init, [1, 0, 0]);
}

//-----------------------------------
// AMMO WORKER SIDE 
//-----------------------------------

var ammoInfo = [];
var AmmoWorker = new Worker('js/ammo_worker.js');
AmmoWorker.postMessage = AmmoWorker.webkitPostMessage || AmmoWorker.postMessage;

AmmoWorker.onmessage = function(e) {
	var phase = e.data.tell;
    
	if( phase === "INIT"){
        introDemo();
	}
	if( phase === "RUN"){
		ammoInfo = e.data.infos;
		var mtx = e.data.matrix;
		var mesh, m;
    	var i = mtx.length;
    	while (i--) {
	    	if( meshs[i] ){
	    		mesh = meshs[i];
	    		m = mtx[i];
	    		if(m[0]==2){ if(mesh.material) if(mesh.material.name=="red") mesh.material = mats[2]; }
	    		else if(m[0]==1){
	    			if(mesh.material) if(mesh.material.name=="blue") mesh.material = mats[1];
	    		    mesh.position.set( m[5], m[6], m[7] );
	    		    mesh.quaternion.set( m[1], m[2], m[3], m[4] );

	    		    if(m[6]<-20){
	    		    	AmmoWorker.postMessage({tell:"SET", id:i, obj:{pos:[0, 30+Math.random()*60, 0]} });
	    		    }
	    	    }
	    	}
	    }
	}
    if( phase === "CLEAR"){
        clearAll();
        if(Editor.getScript()){
            AmmoWorker.postMessage({tell:"START", option:engineOption });
            initDemo();
        }
    }

}

function introDemo() {
    //ADD({type:"ground", size:[300,30,300], pos:[0, -15, 0], rot:[0,0,0], mass:0} );
    ADD({type:"terrain", size:[300,30,300], pos:[0, -5, 0], div:[64,64] });

    var mx,my,mz,py;
    for(var i=1; i< 20; i++){
        mx = 1 + Math.random()*5;
        my = 1 + Math.random()*5;
        mz = 1 + Math.random()*5;
        py=100+i*10;

        ADD({type:"box", size:[mx,my,mz], pos:[0, py, 0], mass:1});
        ADD({type:"sphere", size:[mx,my,mz], pos:[0, py, 0], mass:1});
        ADD({type:"cylinder", size:[mx,my,mx], pos:[0, py, 0], mass:1});
    }

    AmmoWorker.postMessage({tell:"START"});
}


//-----------------------------------
// THREE SIDE 
//-----------------------------------

function init() {
    // init editor
    Editor = new Editor();
    document.body.appendChild( Editor.domElement );
    
    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

    camPos = { horizontal: 90, vertical: 70, distance: 300, automove: false };
    mouse = { ox:0, oy:0, h:0, v:0, mx:0, my:0, down:false, over:false, moving:true };

    renderer = new THREE.WebGLRenderer( {precision: "lowp", antialias: false, alpha:false } );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setClearColor( bgcolor, 1 );

    container = document.getElementById("container");
    container.appendChild( renderer.domElement );
    renderer.autoClear = false;
    renderer.gammaInput = true;
    renderer.gammaOutput = true;
    renderer.shadowMapEnabled = true;
    //renderer.shadowMapCullFace = THREE.CullFaceBack;
    clock = new THREE.Clock()
    // scene
    scene = new THREE.Scene();

    // camera
    camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 0.5, 2000 );
    center = new THREE.Vector3();
    moveCamera();

    scene.add( camera );

    //content for all physics object
    content = new THREE.Object3D();
    scene.add(content);

    // lights
    //hemiLight = new THREE.HemisphereLight( bgcolor, 0xffffff, 1 );
    //hemiLight.color.setHex( 0xb6a385 );
    //hemiLight.groundColor.setHex( 0x4b5054);
    //hemiLight.position.set( 0, 50, 0 );
    //scene.add( hemiLight );

    scene.add( new THREE.AmbientLight( bgcolor ) );

    //directionalLight = new THREE.DirectionalLight( 0xffffee , 1 );
   //directionalLight.position.set(100, 300, 50 );
    //directionalLight.position.multiplyScalar( 100 );
    //scene.add( directionalLight );
    directionalLight = new THREE.DirectionalLight( 0xffffff, 2 );
    directionalLight.position.set( 100, 300, 50 );
    scene.add( directionalLight );

    pointLight = new THREE.PointLight( 0xAACCff, 3);
    pointLight.position.set(0, 0, 0);
    scene.add( pointLight );
    /*var lightMat = new THREE.MeshBasicMaterial( { color: pointLight.color } );
    var lightMesh = new THREE.Mesh( new THREE.SphereGeometry( 2, 6, 6 ), lightMat );
    pointLight.add(lightMesh)*/

    var light = new THREE.SpotLight( 0xffffff, 1.5, 0, Math.PI/2, 1 );
    light.position.set( 100, 300, 50 );

    light.castShadow = true;
    //light.shadowCameraVisible = true;
    light.shadowMapWidth = light.shadowMapHeight = 512;
    light.shadowCameraNear = 50;
    light.shadowCameraFar = 400;
    light.shadowCameraFov = 60;
    light.shadowDarkness = 0.5;

    scene.add( light );

    var backMat = new THREE.MeshBasicMaterial( { color: bgcolor, side:THREE.BackSide, depthWrite: false } );
    var backGeo = new THREE.Mesh( new THREE.SphereGeometry( 500, 6, 6 ), backMat );
    scene.add( backGeo );

    var groundMat = new THREE.MeshBasicMaterial( { color: 0xFFFFFF, transparent:true, blending:THREE.MultiplyBlending } );
    var groundGeo = THREE.BufferGeometryUtils.fromGeometry( new THREE.PlaneGeometry( 1, 1 ) );
    groundGeo.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
    ground = new THREE.Mesh( groundGeo, groundMat );
    ground.position.y = -0.1
    ground.castShadow = false;
    ground.receiveShadow = true;
    scene.add( ground );

    var body = document.body;
    window.addEventListener( 'resize', resize, false );
    container.addEventListener( 'mousemove', onMouseMove, false );
    container.addEventListener( 'mousedown', onMouseDown, false );
    container.addEventListener( 'mouseout', onMouseUp, false );
    container.addEventListener( 'mouseup', onMouseUp, false );
    if( body.addEventListener ){
        body.addEventListener( 'mousewheel', onMouseWheel, false ); //chrome
        body.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox
    }else if( body.attachEvent ){
        body.attachEvent("onmousewheel" , onMouseWheel); // ie
    }

    // load basic model
    pool = new SEA3D.Pool('models/geo.sea', initGeometry);

    

    loop();
}

function loop() {
    requestAnimationFrame( loop );
    var delta = clock.getDelta();
    if( terrain !== null  )terrain.update(delta);
    renderer.render( scene, camera );
    displayInfo();
}

function resize() {
    renderer.setSize( window.innerWidth*viewSize.w, window.innerHeight*viewSize.h );
    camera.aspect = (window.innerWidth*viewSize.w) / (window.innerHeight*viewSize.h );
    camera.updateProjectionMatrix();
}

function displayInfo(){
    time = Date.now();
    if (time - 1000 > time_prev) { time_prev = time; fpsint = fps; fps = 0; } fps++;
    var info =[
        "<h3>Ammo lab</h3><br>",
        "Three : " + fpsint +" fps<br>",
        "Ammo : " + ammoInfo[0]+" fps<br>",
        "rigids : " + ammoInfo[1]+" <br>"
    ].join("\n");
    document.getElementById("info").innerHTML = info;
}

//-----------------------------------------------------
// MESH FUNCTION
//-----------------------------------------------------

function initGeometry() {
    mats[0] = new THREE.MeshPhongMaterial({ color: 0x101010, shininess: 120 });
    mats[1] = new THREE.MeshPhongMaterial({ color: 0xFF0505, shininess: 120, name:"red" });
    mats[2] = new THREE.MeshPhongMaterial({ color: 0x0505FF, shininess: 120, name:"blue" });

    geos[0] = THREE.BufferGeometryUtils.fromGeometry(new THREE.CubeGeometry( 1, 1, 1 ));
    geos[1] = THREE.BufferGeometryUtils.fromGeometry(pool.getGeometry("box", true));
    geos[2] = THREE.BufferGeometryUtils.fromGeometry(new THREE.SphereGeometry( 1, 20, 16  ));
    geos[3] = THREE.BufferGeometryUtils.fromGeometry(pool.getGeometry("cyl", true));
    geos[4] = THREE.BufferGeometryUtils.fromGeometry(pool.getGeometry("dice", true));

    // send AMMO script to worker
    AmmoWorker.postMessage({tell:"INIT", AmmoUrl:scriptLoader.ref["AMMOX"] });
}

var removeObject = function (n) {
    content.remove( content.children[n] );
}

var clearAll = function (){
    if(terrain!== null){ terrain.clear(); terrain = null; }
    var i = content.children.length;
    while (i--) {
        content.remove(content.children[ i ]);
    }

    //if(terrain!== null) terrain = null;
    meshs.length = 0;

}

//-----------------------------------------------------
// TRANSE SCRIPT
//-----------------------------------------------------

var engineOption = null;
//var SET = null;
var debugAlpha = 0.5;
var debugColor = 0xcccccc;
//var CAM = function(h, v, d){ TE.changeView(h, v, d); }

var ADD = function(obj){
    var size = obj.size || [1,1,1];
    var div = obj.div || [64,64];
    var mesh, mesh0;

    switch(obj.type){
        case 'boxbasic': case 'ground': 
            mesh = new THREE.Mesh( geos[0] );
            mesh.scale.set( size[0], size[1], size[2] );
            mesh.visible = false;
            mesh0 = new THREE.BoxHelper( mesh );
            mesh0.material.color.set( debugColor );
            mesh0.material.opacity = debugAlpha;
            mesh0.material.transparent = true;
            mesh.add( mesh0 );
        break;
        case 'box': 
            mesh = new THREE.Mesh( geos[1], mats[1] );
            mesh.scale.set( size[0], size[1], size[2] );
        break;
        case 'sphere':
            mesh = new THREE.Mesh( geos[2], mats[1] );
            mesh.scale.set( size[0], size[0], size[0] );
        break;
        case 'cylinder':
            mesh = new THREE.Mesh( geos[3], mats[1] );
            mesh.scale.set( size[0], size[1], size[2] );
        break;
        case 'dice': 
            mesh = new THREE.Mesh( geos[4], mats[1] );
            mesh.scale.set( size[0], size[1], size[2] );
        break;
        case 'capsule': 
        //shape = new Ammo.btCapsuleShape(size[0]*0.5, size[1]*0.5); 
        break;
        /*case 'cone': shape = new Ammo.btConeShape(size[0]*0.5, size[1]*0.5); break;
        case 'mesh': shape = new Ammo.btBoxShape(new Ammo.btVector3(size[0]*0.5, size[1]*0.5, size[2]*0.5)); break;
        case 'convex': shape = new Ammo.btBoxShape(new Ammo.btVector3(size[0]*0.5, size[1]*0.5, size[2]*0.5)); break;*/
        case 'terrain': 
            terrain = new TERRAIN.Generate( div, size );
            terrain.init( window.innerWidth, window.innerHeight );
            mesh = terrain.container;
        break;
    }

    if(obj.type !== 'boxbasic' || obj.type !== 'ground'){
       mesh.castShadow = true;
       mesh.receiveShadow = true;
    }

    if(obj.type == 'ground'){// ground shadow
        ground.scale.set( size[0], 1, size[2] );
        if(obj.rot)ground.rotation.set( (obj.rot[0])*ToRad, obj.rot[1]*ToRad, obj.rot[2]*ToRad );
        else ground.rotation.set(0,0,0);
    }

    content.add(mesh);
    meshs.push(mesh);

    AmmoWorker.postMessage({ tell:"ADD", obj:obj });
}

//var GET = function(names){ AmmoWorker.postMessage({tell:"GET", names:names}); }

var CLEAR = function(option){
    engineOption = option || {};
    AmmoWorker.postMessage({tell:"CLEAR"});
}

//-----------------------------------
// MATH
//-----------------------------------

function Orbit(origine, horizontal, vertical, distance) {
    var p = new THREE.Vector3();
    var phi = vertical*ToRad;
    var theta = horizontal*ToRad;
    p.x = (distance * Math.sin(phi) * Math.cos(theta)) + origine.x;
    p.z = (distance * Math.sin(phi) * Math.sin(theta)) + origine.z;
    p.y = (distance * Math.cos(phi)) + origine.y;
    return p;
}

//-----------------------------------
// MOUSE & NAVIGATION 
//-----------------------------------

function moveCamera() {
    camera.position.copy(Orbit(center, camPos.horizontal, camPos.vertical, camPos.distance));
    camera.lookAt(center);
}

function onMouseDown(e) {
    e.preventDefault();
    mouse.ox = e.clientX;
    mouse.oy = e.clientY;
    mouse.h = camPos.horizontal;
    mouse.v = camPos.vertical;
    mouse.down = true;
}

function onMouseUp(e) {
    mouse.down = false;
    document.body.style.cursor = 'auto';
}

function onMouseMove(e) {
    e.preventDefault();
    if (mouse.down ) {
        document.body.style.cursor = 'move';
        camPos.horizontal = ((e.clientX - mouse.ox) * 0.3) + mouse.h;
        camPos.vertical = (-(e.clientY - mouse.oy) * 0.3) + mouse.v;
        moveCamera();
    }
}

function onMouseWheel(e) {
    var delta = 0;
    if(e.wheelDelta){delta=e.wheelDelta*-1;}
    else if(e.detail){delta=e.detail*20;}
    camPos.distance+=(delta/10);
    moveCamera();   
    e.preventDefault();
}

</script>
</body>
</html>